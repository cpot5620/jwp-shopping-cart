# jwp-shopping-cart

## 기능 목록
### 인증 및 인가
- 인증
  - 인증 정보가 저장된 유저와 일치하는지 검증한다.
  - 권한에 대한 구현이 없으므로, 인증되면 인가된다.
- 인가된 유저 Id ArgumentResolver
  - 인가된 유저의 Id를 핸들러 인자로 전달한다.

### 컨트롤러

- 웹페이지
    - 상품 목록 `/`
    - 관리자 `/admin`
    - 설정 `/settings`
    - 장바구니 `/cart`
- API
    - 추가 `POST /products`
    - 수정 `PUT /products/{id}`
    - 삭제 `DELETE /products/{id}`
    - 상품 요청 페이로드
        - 이름은 필수이다.
        - 이미지는 필수이다.
            - 2000글자 이내이다.
            - URL이어야 한다.
        - 가격은 필수이다.
    - 장바구니 상품 추가 `POST /cart/items`
    - 장바구니 상품 조회 `GET /cart/items`
    - 장바구니 상품 제거 `DELETE /cart/items/{id}`

### 사용자

사용자 도메인 모델을 표현한다.

- 이메일, 패스워드를 담는다.
- 이메일이 같으면, 같은 사용자다.

### 사용자 DAO

- 사용자를 삽입한다.
    - [ ] 사용자가 이미 존재할 경우 예외를 던진다. -> 어디서 처리할지 고민해본다.
- 사용자를 전체 조회한다.
- Id로 사용자를 조회한다.
- Email로 사용자를 조회한다.

### 상품

- 이름은 20글자 이하이다.
- 금액은 1,000,000원 이하이다.
- 이름, 이미지, 금액이 같으면 같은 상품이다.

### 상품 DAO

상품 DB에 대한 저장, 조회, 삭제 로직을 추상화 및 캡슐화한다.

- 상품을 저장한다
- 상품 하나를 조회한다
- 모든 상품을 조회한다
- 상품을 수정한다
    - 수정된 상품 수를 반환한다.
- 상품을 제거한다
    - 제거된 상품 수를 반환한다.

### 상품 Repository

상품 DAO 사용, 예외, 도메인의 저장, 조회, 삭제를 추상화 및 캡슐화한다.

- 상품을 저장한다.
- 상품을 전체 조회한다.
- 상품을 수정한다.
    - 수정된 대상이 없으면 예외를 던진다.
- 상품을 제거한다.
    - 제거된 대상이 없으면 예외를 던진다.

### 장바구니

- 상품을 추가한다.
- 상품을 제거한다.
- 상품들을 가져온다.
- 소유자가 있다.

### 장바구니 서비스

- 장바구니에 상품을 추가한다.
    - 특정 유저의 장바구니를 가져온다.
    - 장바구니에 추가한다.
    - 장바구니를 저장한다.

- 장바구니에서 상품을 제거한다.
    - 특정 유저의 장바구니를 가져온다.
    - 장바구니에서 물품을 제거한다.
    - 장바구니를 저장한다.

- 장바구니를 가져온다.
    - 특정 유저의 장바구니를 가져온다.

### 장바구니 아이템

- 대상 상품이 있다.
- 상품이 같으면 같은 아이템이다.

### 장바구니 아이템 DAO

- 유저의 장바구니 아이템을 저장한다.
- 유저의 장바구니 아이템을 가져온다.
- 유저의 장바구니 아이템을 비운다.

# 학습 + 복습

## 인증 및 인가
### 인증(Authentication)
인증은 신원 자체를 확인하고 검증하는 행위다.  
> ex) 캠퍼스에 들어가려면 '땡칠'임을 증명하는 출입증이 있어야 한다.  
> 출입증은 '인증 정보'고, '인증'은 그 출입증이 '땡칠'에게 부여된 출입증이 맞는지 확인하는 행위다.

### 인가(Authorization)
인가는 인증된 사용자가 권한이 있는지 확인하는 행위다.
> ex) 앞서 '인증' 과정을 통해 '땡칠'임을 확인했다.  
> '인가'는 이제 출입증과는 별도로, '땡칠'이라는 크루가 캠퍼스에 들어가도 되는지 권한을 확인한다.  
> '땡칠'은 '크루'라는 권한을 가지므로 출입이 허가된다.

## 엔티티 객체에 별도 식별자가 필요한 이유

### 도메인 객체 인스턴스의 생명주기는 데이터의 생명주기와 일치하지 않을 수 있다.

> 예를 들어, 카트 도메인 객체를 저장했다가 꺼낸다고 해보자.  
> 조회를 통해 다시 도메인 객체를 꺼내면, 해당 객체 및 하위 객체의 인스턴스는 바뀐다.  
> 이 경우 동일한 데이터지만 다른 상품 객체, 다른 카트 객체가 된다.

> 따라서 도메인 객체를 동일성으로 식별했던 경우, 영속화 맥락에서는 객체를 올바르게 식별하려면 동일성 외 다른 방법이 필요하다.    
> 하지만, 별도로 정의된 동등성이 있다면 필요하지 않다.  
> 위 이유로 별도의 식별자를 사용하며, 이 식별자의 값은 데이터를 저장하는 측에서 관리한다.

### 결론

> (대상이 DB가 아니더라도) 저장 및 조회의 대상이 되는 객체를 식별하기 위해서는 식별자가 따로 필요하다.  
(+ 이 식별자를 식별 외 다른 곳에 사용하면 오용이다)  
(+ 식별이 필요 없다면 Id도 필요없다)  
> 엔티티는 별도 식별자를 가지는 도메인 객체이고, 그 별도 식별자의 목적은 저장과 조회다.

### 의문점

- 그렇다면 상품의 Id를 식별에 어떻게 활용할 것인가? (완료)
    - Id를 상품 객체의 동등성 비교(equals)에 사용해도 되는가?
        - 중복 허용/방지등의 요구사항이 변경되면, 어떻게 대응해야 하는가?
            - 학습 테스트 `NewEqualityRequirementTest` 참고
        - Id로 식별하면, 객체의 식별을 외부 저장 기술에 의존하는 것이 아닌가?
            - 하기 **EQ & HC 오버라이딩 기준** 참고
        - DB 테이블의 제약 조건(ex, UNIQUE)이 객체지향 세계까지 영향을 미친다.
          > - 맞다. 그리고 잘못된 것이다.   
              도메인이 **가장 핵심 관심사**이고, 이를 표현한 것이 도메인 객체다.  
              따라서 도메인을 잘 저장할 수 있게 고려해야지, 저장된 정보를 도메인 객체로 어떻게 표현할지 고려하면 안된다.  
              이는 **주객전도**된 것이다.  
              따라서, 반대로 객체의 제약 조건이 DB에 영향을 미치는 것이 이상적이다.
        - 아직 저장되지 않은 엔티티끼리는 어떻게 식별할 것인가? (Id가 널인 경우가 있다)
            - 하기 **EQ & HC 오버라이딩 기준** 참고

- Id를 갖는 것 자체가 객체를 특정 저장 기술(DB)에 종속시키는 걸까? 아니면 DB가 관리하는 Id를 객체에 삽입할 때 종속시키는 걸까?

- 객체 자체를 저장하는 방법은 없나?
  > 직렬화/역직렬화. 하지만 이 경우도 메모리 주소가 변하므로 통제 가능한 별도 식별자가 필요하다.  
  > DB에 저장하고, 불러오는 것도 직렬화/역직렬화의 일종인 것 같다. (실제로 `BeanPropertySqlParameterSource`는 JavaBean 정의를 기반으로 직렬화한다)  
  다른 점은 **정보를 원하는 형태로 저장**하도록 하는 것이 목적이라는 점이다. (테이블은 성능, 명확성, 유연성 등을 위해 객체의 형태와 다를 수도 있다)

## 엔티티 객체 EQ & HC 오버라이딩 기준(뇌피셜)

- [ ] HC는 아직 해결하지 못했다.

### Id로 비교해야 하는 경우

- **DB가 없다고 가정했을 때, 상품을 동일성(메모리 주소)으로 식별하도록 설계했다면?**
    - 동일한 필드를 가지는 도메인 객체를 허용했으며, 동일한 인스턴스는 같은 상품으로 본 것이다.
    - 즉, 메모리 주소로 도메인 객체를 식별했다.
    - 따라서 영속화 맥락을 고려했을 땐 `Id`로 식별을 이어나가야 한다.
        - `Id`의 목적은 '데이터 자체'의 식별이기 때문이다.
            - ex) 테이블이라면 한 행을 식별하는 것이 목적이다
            - > 인스턴스의 생명 주기와 데이터의 생명 주기는 다르다.  
              영속화 후 인스턴스화 했을 때는 메모리 주소가 달라진다.  
              따라서 '데이터 자체'를 식별하기 위해서는 Id를 사용해야 한다.

### Id를 빼고 비교해야 하는 경우

- **비즈니스 룰이 별도로 존재하는 경우**
    - 비즈니스 로직 안에서 결정해버리면 잘못된 데이터가 DB까지 내려갈 일이 없다.
        - (정말 불안하다면, DB에다가도 동일한 제약조건을 추가하면 오히려 가장 안전한 것 아닌가?)
    - > 만약 이 경우에도 `Id`로 식별하거나 `Id`를 포함해 식별한다면, `도메인의 저장 방식`을 도메인이 알게 된다.  
      비즈니스 룰이 있는데도 Id를 도메인의 식별에 활용하는 것은 책임을 훨씬 벗어난 행위다.

### (공통) 아직 영속화되지 않은 경우

#### 두 비교 대상 중 하나만 `Id`가 `null`인 경우 (미해결)

이런 경우를 고려하지 않으려면, 확실히 비즈니즈 룰이 필요하다.  
하지만 항상 그렇게 이상적인 상황일리가 없다.

현재 미션으로 한정지어 생각해봤을 때, 영속화는 나누어 이뤄지지않고, 한 번에 이뤄진다.  
따라서 한 쪽만 저장되었다면 원래 같은 인스턴스였을리가 없다.

하지만 이 논리는 일관적이지도 않고, 현재 상황에만 한정된다.
여러 번에 나눠서 저장된다면, 데이터를 식별할 방법이 아예 없다.
> 예를 들어보자.
> 상품 A(인스턴스1)를 생성했다.
> 상품 A 을 저장하고 다시 객체화하면, 상품 A는 기존 인스턴스1과 같은 데이터지만 다르다고 판정된다.


#### 두 비교 대상 모두 `Id`가 `null`인 경우

객체의 `Id`가 `null`일 수도 있다.   
이 경우 DB를 떼고 생각하면 된다.  
동일성(메모리 주소)으로 식별하고 있었다면 유지해야 하고,   
비즈니스 로직으로 식별하고 있었다면 마찬가지로 유지해야한다.  
(`domain.Product` 엔티티 객체 참고)

> 이렇게 직접 판단을 끝내고 찾아보니 이런 Stackoverflow 답변이 있다.  
> 아쉽지만 누군가와 의견을 나눈 셈 쳐야겠다.  
> 미리 찾아봤으면 시간을 아꼈겠지만, 과연 이렇게 직접 판단해봤을까 싶긴 하다.  
> https://stackoverflow.com/a/4388453

## Service 레이어의 목적, 필요성 (복습)

- 여러 도메인이 연관되는 비즈니스 로직은 수행하는 방법도 간단하지 않으며, 로직 실행 순서마저 비즈니스 로직이다. (절차)
- 따라서 이런 비즈니스 로직을 수행하는 방법에 대한 관심사를 분리하고 캡슐화하기 위해 서비스 레이어가 필요하다. (이것이 도메인 서비스일까요?)

## DAO가 도메인에 의존성을 가지지 않아야 할 이유

간단한 도메인도 Repository가 필요할까?

- [x] UserRepository를 만들지 않는다.
- [ ] User 도메인을 그대로 전달하고, 조회할 때도 완전한 도메인을 만들어 반환해준다.

- 후기
    - (아직 안했습니다!)

## Repository의 목적, 필요성 (복습)

**DAO에 도메인 객체 구성 및 반환, 도메인 객체를 저장할 책임을 부여해본다.**

- 요구 사항
    - CartRepository를 만들지 않는다.

- 후기
    - Cart는 여러 도메인들이 연관된 도메인이므로, 이 도메인을 조회하고 구성하는 것은 간단하지는 않다. (뚝딱 불가능)
    - 따라서 (Cart 도메인을 저장하고, 꺼내는 방법)을 캡슐화해서 관심사를 분리할 필요가 있다.
    - 즉, 여러 도메인을 포함한 도메인이라면 Repository를 사용할 때 유지보수 관점에서 캡슐화의 이점이 크다.
